
# mkcd
# Make and change directory shortcut
# Usage: mkcd [directory]
mkcd() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: mkcd \e[2m[directory]\e[0m"
  elif [ -d $1 ]; then
    echo -e "\e[31mError:\e[0m Directory \`$1\` already exists"
  else
    mkdir $1 && cd $1
  fi
}

# touch
# Improved touch for nested files
touch() {
  if [ $# -eq 0 ]; then
  command touch;
  return; fi;
  local f
  for f in "$@"; do
    command mkdir -p "$(dirname "$f")" && command touch "$f"
  done
}

# src
# Shorthand to navigate files in the source directory.
# Usage: src folder-name/
src() {
  if [ $# -eq 0 ]; then
    cd "$SRC"
    return;
  fi
  cd "$SRC/$1"
}
_src() {
  local IFS='\n'
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local root="${SRC}"
  local path="${root}${cur}"
  local matches=$(compgen -d -- "$path")
  local results=()
  while read -r match; do
    results=("${results[@]}" "${match#$SRC}/")
  done <<< "$matches"
  COMPREPLY=$results
  return 0
}
complete -o default -o nospace -F _src src

# DNS Record Lookup
# Shows all DNS records tied to a given domain
# Usage: dns [domain name]
dns() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: dns \e[2m[domain name]\e[0m"
    return;
  fi
  dig +nocmd "$1" any +multiline +noall +answer
}

# Base64 Encoder
# Encodes a file to base64. Pairs well with `pbcopy`
# Usage: btoa [file]
btoa() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: btoa \e[2m[file]\e[0m"
    return;
  fi
  if [ ! -f $1 ]; then
    echo -e "\e[31mError:\e[0m Could not find file \`$1\`"
    return;
  fi
  cat $1 | openssl base64 | tr -d '\n'
}

# URL Stress Testing
# Creates a number of requests for a certain length of time to a specific URL,
# and requires http_load be installed (`brew install http_load`)
# Usage: httpload [url] [clients] [seconds]
httpload() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: httpload \e[2m[url] [clients] [seconds]\e[0m"
    return;
  fi
  STAMP=`date +"%s"`;
  echo "http://$1" > /var/tmp/$STAMP.http_load_temp_file
  http_load -parallel $2 -seconds $3 /var/tmp/$STAMP.http_load_temp_file
  rm -f /var/tmp/$STAMP.http_load_temp_file
}

# Compare original and gzipped file size
# Usage: gz [input]
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
	printf "Original: %d bytes\n" "$origsize"
	printf "Gzipped:  %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# HTML5 Video Encoding
# Converts an input mp4 video into either a web-optimized .mp4 or a .webm file.
# The preset bitrates are a max rate and target rate of 5M, and min rate of 4M.
# Requires ffmpeg (`brew install ffmpeg --with-theora --with-libvorbis`)
# Usage: encode [input] [output]
encode() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: encode \e[2m[input] [output]\e[0m"
    return;
  fi
  OUTPUT_FILE=$(basename "$2")
  OUTPUT_EXTENSION="${OUTPUT_FILE##*.}"
  # can either be libx264 or libvpx
  case "$OUTPUT_EXTENSION" in
    mp4)  CODEC="libx264" ;;
    webm) CODEC="libvpx" ;;
    ogv)  CODEC="libtheora" ;;
    *) echo -e "\e[31mError:\e[0m mp4, webm, and ogv are the only supported outputs."; return ;;
  esac
  ffmpeg -i "$1" -c:v "$CODEC" -b:v 5M "$2"
}

# watsi
# Utilities for working with the Watsi codebase
# Usage: watsi [cmd] [args]

watsi () {
  # assert arguments
  [ $# -ne 1 ] && __watsi_help && return

  # switch arguments
  case $1 in
    o|open) __watsi_open;;
    e|edit) __watsi_edit;;
    s|start) __watsi_start;;
    k|kill) __watsi_kill;;
    -h|--help) __watsi_help;;
  esac
}

__watsi_open () {
  open $SRC/watsi
}

__watsi_edit () {
  cd $SRC/watsi
  atom .
}

__watsi_start () {
  trap __watsi_kill INT TERM
  cd $SRC/watsi
  foreman start -f Procfile-development
}

__watsi_kill () {
  echo "Shutting down..."
  local smtp=$(lsof -ti tcp:1025)
  local mailcatcher=$(lsof -ti tcp:1080)
  local server=$(lsof -ti tcp:4000)
  local jasmine=$(lsof -ti tcp:8888)
  local sidekiq=$(lsof -ti tcp:6379)

  if [[ -n ${smtp} ]]; then
    kill -9 ${smtp}
  fi

  if [[ -n ${mailcatcher} ]]; then
    kill -9 ${mailcatcher}
  fi

  if [[ -n ${jasmine} ]]; then
    kill -9 ${jasmine}
  fi

  if [[ -n ${server} ]]; then
    kill -9 ${server}
  fi

  if [[ -n ${sidekiq} ]]; then
    kill -9 ${sidekiq}
  fi
}

__watsi_help () {
  echo -e ""
  echo -e "  Usage: watsi \e[2m[cmd] [args]\e[0m"
  echo -e ""
  echo "  Commands:"
  echo ""
  echo "    open      Open source folder in Finder"
  echo "    edit      Open source folder in editor"
  echo "    start     Start server"
  echo "    kill      Kill server"
  echo ""
}

__watsi_complete () {
  COMPREPLY=()
	local cur="${COMP_WORDS[COMP_CWORD]}"
  local commands="open edit start kill"
  COMPREPLY=($(compgen -W "${commands}" -- ${cur}))
  return 0
}

complete -o nospace -F __watsi_complete watsi
