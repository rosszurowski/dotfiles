# mkcd
# Make and change directory shortcut
# Usage: mkcd [directory]
mkcd() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: mkcd \e[2m[directory]\e[0m"
  elif [ -d $1 ]; then
    echo -e "\e[31mError:\e[0m Directory \`$1\` already exists"
  else
    mkdir $1 && cd $1
  fi
}

# touch
# Improved touch for nested files
touch() {
  if [ $# -eq 0 ]; then
  command touch;
  return; fi;
  local f
  for f in "$@"; do
    command mkdir -p "$(dirname "$f")" && command touch "$f"
  done
}

# src
# Shorthand to navigate files in the source directory.
# Usage: src folder-name/
src() {
  if [ $# -eq 0 ]; then
    cd "$SOURCE"
    return;
  fi
  cd "$SOURCE/$1"
}
complete -o "nospace" -W "$(ls $SOURCE)" src

# URL Stress Testing
# Creates a number of requests for a certain length of time to a specific URL,
# and requires http_load be installed (`brew install http_load`)
# Usage: httpload [url] [clients] [seconds]
httpload() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: httpload \e[2m[url] [clients] [seconds]\e[0m"
    return;
  fi
  STAMP=`date +"%s"`;
  echo "http://$1" > /var/tmp/$STAMP.http_load_temp_file
  http_load -parallel $2 -seconds $3 /var/tmp/$STAMP.http_load_temp_file
  rm -f /var/tmp/$STAMP.http_load_temp_file
}

# Send OS X Notification
# Connects with the notification center to trigger an OS-level notification
# Usage: notify [title] [message]
notify() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: notify \e[2m[message]\e[0m"
    return;
  fi
  osascript -e "display notification \"$2\" with title \"$1\""
}

# Notational Velocity Linker
# Creates a Finder link to a note in Notational Velocity. This is useful for
# providing references back to my notes, which have traditionally been
# easily forgotten.
# Usage: nvlink [note]
nvlink() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: nvlink \e[2m[note]\e[0m"
    return;
  fi
  local note=$1
  local dest="./${note}.webloc"
  touch "$dest"
  SetFile -a E "$dest"
  local uri=`node -pe "encodeURI('${note}')"`
  cat > "$dest" <<EOL
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>URL</key>
  <string>nv://find/${uri}</string>
</dict>
</plist>
EOL
}

# Convert video to GIF
# --start
# --end
# --duration
# --width
# --height
# --frame-rate
# Adapted from http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html
gif() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: gif \e[2m[input] [output] [options...]\e[0m"
    return;
  fi

  echo -e "\e[2mStill being implemented...\e[0m"
  return;

  PALETTE="/tmp/palette.png"
  FILTERS="fps=18,scale320:-1:flags=lanczos"

  ffmpeg -v warning -i "$1" -vf "$FILTERS,palettegen" -y $PALETTE
  ffmpeg -v warning -i "$1" -i "$PALETTE" -lavfi "$FILTERS [x]; [x][1:v] paletteuse" -y $2
  rm -f $PALETTE

}

# HTML5 Video Encoding
# Converts an input mp4 video into either a web-optimized .mp4 or a .webm file.
# The preset bitrates are a max rate and target rate of 5M, and min rate of 4M.
# Requires ffmpeg (`brew install ffmpeg --with-theora --with-libvorbis`)
# Usage: encode [input] [output]
encode() {
  if [ $# -eq 0 ]; then
    echo -e "Usage: encode \e[2m[input] [output]\e[0m"
    return;
  fi
  OUTPUT_FILE=$(basename "$2")
  OUTPUT_EXTENSION="${OUTPUT_FILE##*.}"
  # can either be libx264 or libvpx
  case "$OUTPUT_EXTENSION" in
    mp4)  CODEC="libx264" ;;
    webm) CODEC="libvpx" ;;
    ogv)  CODEC="libtheora" ;;
    *) echo -e "\e[31mError:\e[0m mp4, webm, and ogv are the only supported outputs."; return ;;
  esac
  ffmpeg -i "$1" -c:v "$CODEC" -b:v 5M "$2"
}
